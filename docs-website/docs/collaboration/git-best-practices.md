# Git Best Practices

Draft of documentation, to be reviewed and improved.
<details>
<summary><strong>Git Best Practices (Draft content)</strong></summary>

# Git Best Practices

## Branch Naming
- Use lowercase letters
- Separate words with hyphens
- Be descriptive but concise
- Example: `add-user-authentication` or `fix-memory-leak-in-image-processing`

## Commit Organization and Messages
- Review each file you're adding to your commit
- Group related changes in a single commit
- Use descriptive commit messages in present-tense, imperative mood
- If necessary, add a small description of why/what for each file changed

Example commit structure:
```
Commit 1: "Add logger environment variables"
* Logger destination is needed so:
  - Add var to .env.example backend file
  - Add var to config validation in backend

Commit 2: "Set up Pino logging"
* Add Pino module
* Add Pino module to global Nest backend configuration for use in all app modules
* ...
```

## Commit Message Style: Present-Tense, Imperative Mood

Use present-tense, imperative-style commit messages as recommended by the Git project:

> Describe your changes in imperative mood, e.g. "make xyzzy do frotz" instead of "[This patch] makes xyzzy do frotz" or "[I] changed xyzzy do frotz", as if you are giving orders to the codebase to change its behavior.

Examples:
- "Add user authentication feature" (not "Added" or "Adds")
- "Fix memory leak in image processing" (not "Fixed" or "Fixes")
- "Update logger configuration" (not "Updated" or "Updates")

Reasons for this style:
1. Consistency with Git's own automated messages
2. Reads as a command to the codebase
3. Often results in shorter, more direct messages
4. Aligns with widely-used Git conventions

## Merge Requests
Include the following in your merge request description:
1. Summary of changes
2. Reason for changes
3. Impact of changes
4. Any potential risks or areas needing extra attention

Use proper Markdown formatting for readability. Consider using an LLM to help with formatting and language accuracy, but always re-read and verify the content yourself.

## Commit Squashing
- Squashing before merge should be automatic and managed by the repository hosting platform (e.g., GitLab)
- The squash commit message should summarize the overall change
- Detailed information about the changes should be in the completed merge request

## Development vs. Merged Commits
- Commit messages are most useful during the development phase of a branch
- After merging, the squashed commit and the merge request description become the primary sources of information about the changes

Remember to always review your work, whether it's code, commit messages, or merge request descriptions. Clear communication about your changes is crucial for effective collaboration and future maintenance of the project.

</details>

> **Disclaimer**: The following documentation was entirely generated by an LLM and has not been verified at this time. I do not yet have extensive experience in this area. This document serves as a draft guideline for areas where I should gain knowledge to improve the Git workflow and collaboration practices.

<details>
<summary><strong>Git Best Practices (Generated Content)</strong></summary>

> **Info**: Git is a powerful tool for version control and collaboration. Following these best practices will help maintain a clean, understandable project history and facilitate effective teamwork.

1. **Commit Messages**:
   - Write clear, concise commit messages
   - Use the imperative mood (e.g., "Add feature" not "Added feature")
   - Structure messages as: 
     ```
     Short summary (50 chars or less)

     More detailed explanatory text, if necessary. Wrap it to about 72
     characters. The blank line separating the summary from the body is
     critical (unless you omit the body entirely).

     Further paragraphs come after blank lines.

     - Bullet points are okay, too
     - Use a hanging indent
     ```

2. **Branching Strategy**:
   - Use feature branches for all new features and bug fixes
   - Adopt a consistent naming convention (e.g., `feature/add-login`, `bugfix/fix-memory-leak`)
   - Keep branches focused and short-lived

3. **Pull Requests**:
   - Create PRs early and mark as "Draft" if not ready for review
   - Keep PRs small and focused on a single feature or fix
   - Provide a clear description of changes and their purpose

4. **Rebasing vs. Merging**:
   - Prefer rebasing feature branches onto main before merging
   - Use `git merge --no-ff` for feature branches to preserve context

5. **Commit Frequency**:
   - Commit often, push regularly
   - Each commit should represent a logical, working change

6. **Git Hooks**:
   - Use pre-commit hooks for linting and formatting
   - Use pre-push hooks for running tests

7. **Tagging**:
   - Use semantic versioning for release tags (e.g., v1.0.0)
   - Annotate tags with release notes

8. **Git Ignore**:
   - Maintain a comprehensive `.gitignore` file
   - Exclude build artifacts, dependencies, and environment-specific files

9. **Large Files**:
   - Avoid committing large files to the repository
   - Use Git LFS for necessary large files

10. **Commit Signing**:
    - Configure Git to sign commits with GPG keys
    - Verify signed commits in critical branches

Remember, these practices are guidelines. Adapt them to your team's needs and project requirements. Consistency across the team is key to leveraging Git effectively for collaboration.

</details>